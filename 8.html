<!DOCTYPE html>
<html>
<style>
	#slidecontainer {
		width: 100%;
	}

	.slider {
		-webkit-appearance: none;
		width: 100%;
		height: 15px;
		border-radius: 5px;
		background: #d3d3d3;
		outline: none;
		opacity: 0.7;
		-webkit-transition: .2s;
		transition: opacity .2s;
	}

	.slider:hover {
		opacity: 1;
	}

	.slider::-webkit-slider-thumb {
		-webkit-appearance: none;
		appearance: none;
		width: 25px;
		height: 25px;
		border-radius: 50%;
		background: #4CAF50;
		cursor: pointer;
	}

	.slider::-moz-range-thumb {
		width: 25px;
		height: 25px;
		border-radius: 50%;
		background: #4CAF50;
		cursor: pointer;
	}
</style>
  <body>
	<div id="container" align="center">
		<input type ="button" class = "button button2" value="sustabdyti/paleisti" id=toggle> 
		<canvas id="myCanvas" width="1000" height="600"></canvas>
		<div id="slidecontainer">
			<p>EF ilgis: <span id="demo"></span></p>
			<input type="range" min="1" max="200" value="50" class="slider" id="myRange">
		
			<p>BF ilgis: <span id="demo2"></span></p>
			<input type="range" min="1" max="100" value="50" class="slider" id="myRange2">
		</div>
	</div>
		
    <script>
      window.requestAnimFrame = (function(callback) {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
        function(callback) {
          window.setTimeout(callback, 1000 / 60);
        };
      })();
	  
	  document.getElementById('toggle').addEventListener('click',function(){
		if(continueAnimating)
			continueAnimating = false;
		else
			continueAnimating = true;
		});	
	 
	  var pathOfCornerCrossing = new Array();
      function draw(myLink, ctx) {
        ctx.beginPath();
        ctx.rect(-myLink.off, -myLink.off, myLink.width+2*myLink.off, 2*myLink.off);
        ctx.fillStyle = myLink.color;
        ctx.fill();
        ctx.lineWidth = myLink.borderWidth;
        ctx.strokeStyle = 'black';
        ctx.stroke();
        ctx.beginPath();        
        ctx.arc(0,0,myLink.borderWidth/2,0,Math.PI*2,true);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.beginPath();        
        ctx.arc(myLink.width,0,myLink.borderWidth/2,0,Math.PI*2,true);
        ctx.fillStyle = 'white';
        ctx.fill();
      }
	  
	  function calc(a, b, c) {
		  return Math.acos((b.width*b.width+c.width*c.width-a.width*a.width)/((2*b.width*c.width)));
	  }
	  
	  function drawPath(array, ctx){
		ctx.save();
        ctx.translate(canvas.width/2-100,canvas.height/2);

        for (var j = 2; j < array.length; j+=2) {
          var ratio = j/500;
          var rgb = new Array();

          //console.log("rgb("+rgb[0]+","+rgb[1]+","+rgb[2]+")");
          ctx.beginPath();
          ctx.lineWidth = 3;
          ctx.moveTo(array[j-2], array[j-1]);
          ctx.lineTo(array[j], array[j+1]);
          ctx.stroke();
        }
        ctx.restore();
      }
	  
      function animate(abLink, bcLink, cdLink, cLink, bdLink, efLink,beLink, ceLink, bfLink, canvas, ctx, startTime) {
         // update
        var time = (new Date()).getTime() - startTime;
        var t = time / 50;
        
		bfLink.width = bfLength ;
		efLink.width = efLength ;
		
		// TODO: pradzia pakeisti nepatinka man jinai.
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // store initial coordinates
        ctx.save(); // [M0]
        ctx.save(); // [M0,M0]
        ctx.translate(canvas.width/2+100,canvas.height/2);
		var th1 = Math.PI/180*t
		ctx.rotate(th1); 
		
        ctx.restore();  // M0 [M0]		
        ctx.translate(canvas.width/2-100,canvas.height/2);
		ctx.save();  // [M1,M0]
		ctx.save();
		alpha = -th1;
		ctx.rotate(alpha);
		
		
		draw(abLink, ctx);
		
        var BD = Math.sqrt(abLink.width*abLink.width + adLink.width*adLink.width - 2*abLink.width*cLink.width*Math.cos(alpha));
		var theta = angle(BD,abLink.width,adLink.width); //ABD
		var beta = angle(adLink.width, BD, abLink.width); //ADB
		var gamma = angle(abLink.width,adLink.width,BD); //DAB
		var delta = angle(BD, cdLink.width, bcLink.width); //ADC
		var tau = angle(BD, bcLink.width, cdLink.width);
	
	    ctx.translate(abLink.width,0); // kad galima butu kabinti BC
		
		// trikampio skaiciavimai
		var BE = Math.sqrt(bfLink.width * bfLink.width + efLink.width * efLink.width); // BF^2 + EF^2
		var ebf = angle(BE,bfLink.width,efLink.width);// EBF
		var FC = bcLink.width - bfLink.width;
		ceLink.width = Math.sqrt(efLink.width * efLink.width + FC * FC); // EF^2 + EC^2
		var fce = angle(FC, ceLink.width, efLink.width); // FCE
		
		
		//1  variantas
	    if (((th1)%(Math.PI*2)) > Math.PI){
		// uz apacios veikima atsakingas
			ctx.rotate(Math.PI + theta);
			bdLink.width = BD; // galim priskirti kadangi, niekam nera priskirtas
		
			//draw(bdLink, ctx); // zalia BD piesia
			ctx.rotate(-tau);	///////// speju negeras kampas
		
		 	draw(bcLink, ctx);  // BC
			ctx.save();
			draw(bfLink,ctx);       // BF (turetu buti reguliuojamas)
			
			ctx.save();
			ctx.rotate(-ebf);
			beLink.width = BE;
			draw(beLink,ctx);
			ctx.restore();
			
			ctx.save();
			ctx.translate(bfLink.width,0);
			ctx.rotate(-Math.PI/2);
			draw(efLink,ctx);   // EF
			ctx.restore();
	
			ctx.translate(bcLink.width,0);
			ctx.rotate(Math.PI + fce);
            draw(ceLink, ctx); // CE piesia

		}else{ // virsaus veikimas
		    ctx.save();
		    ctx.rotate(Math.PI - theta); //PI - theta
			bdLink.width = BD;
		   	//draw(bdLink, ctx);// BD piesia
			ctx.restore();
			ctx.rotate(-(theta + tau) + Math.PI);
			draw(bcLink, ctx); // BC
			draw(bfLink,ctx);       // BF (turetu buti reguliuojamas)
			
			ctx.save();
			ctx.rotate(-ebf);
			beLink.width = BE;
			draw(beLink,ctx);
			ctx.restore();
			
			ctx.save();
			ctx.translate(bfLink.width,0);
			ctx.rotate(-Math.PI/2);
			draw(efLink,ctx);   // EF
			ctx.restore();
	
			ctx.translate(bcLink.width,0);
			ctx.rotate(Math.PI + fce);
            draw(ceLink, ctx); // CE piesia
		
		}
		
// 2 var
/*
		 if (((th1)%(Math.PI*2)) > Math.PI){
		// uz apacios veikima atsakingas
			ctx.rotate(Math.PI + theta);
			bdLink.width = BD; // galim priskirti kadangi, niekam nera priskirtas
		
			//draw(bdLink, ctx); // zalia BD piesia
			ctx.rotate(tau);	///////// speju negeras kampas
		
		 	draw(bcLink, ctx);  // BC
			ctx.save();
			draw(bfLink,ctx);       // BF (turetu buti reguliuojamas)
			
			ctx.save();
			ctx.rotate(-ebf);
			beLink.width = BE;
			draw(beLink,ctx);
			ctx.restore();
			
			ctx.save();
			ctx.translate(bfLink.width,0);
			ctx.rotate(-Math.PI/2);
			draw(efLink,ctx);   // EF
			ctx.restore();
	
			ctx.translate(bcLink.width,0);
			ctx.rotate(Math.PI + fce);
            draw(ceLink, ctx); // CE piesia

		}else{ // virsaus veikimas
		    ctx.save();
		    ctx.rotate(Math.PI - theta); //PI - theta
			bdLink.width = BD;
		   	//draw(bdLink, ctx);// BD piesia
			ctx.restore();
			ctx.rotate(-(theta + tau) + Math.PI);
			draw(bcLink, ctx); // BC
			draw(bfLink,ctx);       // BF (turetu buti reguliuojamas)
			
			ctx.save();
			ctx.rotate(-ebf);
			beLink.width = BE;
			draw(beLink,ctx);
			ctx.restore();
			
			ctx.save();
			ctx.translate(bfLink.width,0);
			ctx.rotate(-Math.PI/2);
			draw(efLink,ctx);   // EF
			ctx.restore();
	
			ctx.translate(bcLink.width,0);
			ctx.rotate(Math.PI + fce);
            draw(ceLink, ctx); // CE piesia
		
		}
		*/
    // 3 var virsus kaip apacia
	/*
		if (((th1)%(Math.PI*2)) > Math.PI){
		// uz apacios veikima atsakingas
			ctx.rotate(Math.PI + theta);
			bdLink.width = BD; // galim priskirti kadangi, niekam nera priskirtas
		
			//draw(bdLink, ctx); // zalia BD piesia
			ctx.rotate(-tau);	///////// speju negeras kampas
		
		 	draw(bcLink, ctx);  // BC
			ctx.save();
			draw(bfLink,ctx);       // BF (turetu buti reguliuojamas)
			
			ctx.save();
			ctx.rotate(-ebf);
			beLink.width = BE;
			draw(beLink,ctx);
			ctx.restore();
			
			ctx.save();
			ctx.translate(bfLink.width,0);
			ctx.rotate(-Math.PI/2);
			draw(efLink,ctx);   // EF
			ctx.restore();
	
			ctx.translate(bcLink.width,0);
			ctx.rotate(Math.PI + fce);
            draw(ceLink, ctx); // CE piesia

		}else{ // virsaus veikimas
		    //ctx.save();
		    ctx.rotate(theta); //PI - theta
			bdLink.width = BD;
		   	draw(bdLink, ctx);// BD piesia
		   	draw(bdLink, ctx);// BD piesia
			//ctx.restore();
			ctx.rotate(tau);
			draw(bcLink, ctx); // BC
			draw(bfLink,ctx);       // BF (turetu buti reguliuojamas)
			
			ctx.save();
			ctx.rotate(-ebf);
			beLink.width = BE;
			draw(beLink,ctx);
			ctx.restore();
			
			ctx.save();
			ctx.translate(bfLink.width,0);
			ctx.rotate(-Math.PI/2);
			draw(efLink,ctx);   // EF
			ctx.restore();
	
			ctx.translate(bcLink.width,0);
			ctx.rotate(Math.PI + fce);
            draw(ceLink, ctx); // CE piesia
		
		}
     */   
		ctx.restore();  // M0 [M0]		
		
        ctx.restore(); // M1 [M0] 
        draw(adLink, ctx); // AD
        
		//1var gerai
		if (((th1)%(Math.PI*2)) > Math.PI){ //apacioje AB
			//console.log("PSI" + psi);
		    var psi = Math.PI + (beta - delta);
		    psi = -psi;
			ctx.translate(adLink.width, 0);
			ctx.rotate(psi);
			draw(cdLink, ctx); // DC
		}else{ // virsus
			// DC piesimas
			var psi = Math.PI - beta - delta;
			psi = -psi;
			ctx.translate(adLink.width, 0);
			ctx.rotate(psi);
			draw(cdLink, ctx); // DC
	    }
		
		
		// 2 var 
		/*
		if (((th1)%(Math.PI*2)) > Math.PI){ //apacioje AB
			//console.log("PSI" + psi);
		    var psi = Math.PI - (beta + delta);
		    psi = -psi;
			ctx.translate(adLink.width, 0);
			ctx.rotate(-psi);
			draw(cdLink, ctx); // DC
		}else{ // virsus
			// DC piesimas
			var psi = Math.PI - beta - delta;
			psi = -psi;
			ctx.translate(adLink.width, 0);
			ctx.rotate(psi);
			draw(cdLink, ctx); // DC
	    }
		*/
		
		// 3 var virsus kaip apacia
		/*
		if (((th1)%(Math.PI*2)) > Math.PI){ //apacioje AB
			//console.log("PSI" + psi);
		    var psi = Math.PI + (beta - delta);
		    psi = -psi;
			ctx.translate(adLink.width, 0);
			ctx.rotate(psi);
			draw(cdLink, ctx); // DC
		}else{ // virsus
			// DC piesimas
			var psi = Math.PI - (beta + delta);
			psi = -psi;
			ctx.translate(adLink.width, 0);
			ctx.rotate(psi);
			draw(cdLink, ctx); // DC
	    }
	*/
        ctx.restore(); // M0 [] 
        ctx.restore(); // M0 [] 
		
		
		
		var cornerCBE = calc(ceLink,bcLink,beLink);
		// 1 variantas
		if (((th1)%(Math.PI*2)) > Math.PI){
		/// Math.PI+theta+beta-Math.PI+charlie blogai, bet kazkoki apskritima nupiesia
			 pathOfCornerCrossing.push(Math.cos(-Math.PI/180*t) * abLink.width + Math.cos(-Math.PI/180*t + Math.PI + theta - tau - cornerCBE) * beLink.width);
			 pathOfCornerCrossing.push(Math.sin(-Math.PI/180*t) * abLink.width + Math.sin( -Math.PI/180*t + Math.PI + theta - tau - cornerCBE) * beLink.width);
		}else{
			 pathOfCornerCrossing.push(Math.cos(-Math.PI/180*t) * abLink.width + Math.cos(-Math.PI/180*t -(theta + tau) + Math.PI - cornerCBE) * beLink.width);
			 pathOfCornerCrossing.push(Math.sin(-Math.PI/180*t) * abLink.width + Math.sin( -Math.PI/180*t -(theta + tau) + Math.PI - cornerCBE) * beLink.width);
		}
		
		
		// 2 variantas
		/*
		if (((th1)%(Math.PI*2)) > Math.PI){
		/// Math.PI+theta+beta-Math.PI+charlie blogai, bet kazkoki apskritima nupiesia
			 pathOfCornerCrossing.push(Math.cos(-Math.PI/180*t) * abLink.width + Math.cos(-Math.PI/180*t + Math.PI + theta + tau - cornerCBE) * beLink.width);
			 pathOfCornerCrossing.push(Math.sin(-Math.PI/180*t) * abLink.width + Math.sin( -Math.PI/180*t + Math.PI + theta + tau - cornerCBE) * beLink.width);
		}else{
			 pathOfCornerCrossing.push(Math.cos(-Math.PI/180*t) * abLink.width + Math.cos(-Math.PI/180*t -(theta + tau) + Math.PI - cornerCBE) * beLink.width);
			 pathOfCornerCrossing.push(Math.sin(-Math.PI/180*t) * abLink.width + Math.sin( -Math.PI/180*t -(theta + tau) + Math.PI - cornerCBE) * beLink.width);
		}*/
		
		
		
		// 3 variantas
		/*
		if (((th1)%(Math.PI*2)) > Math.PI){
		/// Math.PI+theta+beta-Math.PI+charlie blogai, bet kazkoki apskritima nupiesia
			 pathOfCornerCrossing.push(Math.cos(-Math.PI/180*t) * abLink.width + Math.cos(-Math.PI/180*t + Math.PI + theta - tau - cornerCBE) * beLink.width);
			 pathOfCornerCrossing.push(Math.sin(-Math.PI/180*t) * abLink.width + Math.sin( -Math.PI/180*t + Math.PI + theta - tau - cornerCBE) * beLink.width);
		}else{
			 pathOfCornerCrossing.push(Math.cos(-Math.PI/180*t) * abLink.width + Math.cos(-Math.PI/180*t -(theta + tau) + Math.PI - cornerCBE) * beLink.width);
			 pathOfCornerCrossing.push(Math.sin(-Math.PI/180*t) * abLink.width + Math.sin(-Math.PI/180*t -(theta + tau) + Math.PI  - cornerCBE) * beLink.width);
		}*/
		
		if(pathOfCornerCrossing.length > 5000){
          pathOfCornerCrossing.reverse();
          pathOfCornerCrossing.pop();
          pathOfCornerCrossing.pop();
          pathOfCornerCrossing.reverse();
        }
		drawPath(pathOfCornerCrossing, ctx, true);
		
		ctx.restore();
		
		

		
        requestAnimFrame(function() {
          animate(abLink, bcLink, cdLink, adLink, bdLink, efLink, beLink, ceLink, bfLink, canvas, ctx, startTime);
        });
      }
	  
	  
	  function angle(a, b, c){
			return Math.acos((a * a + b * b - c * c) / (2*a*b));
      }  
	  
      var canvas = document.getElementById('myCanvas');
      var ctx = canvas.getContext('2d');
	  
	  
      var abLink = { 
        color: '#8ED6FF',
        width: 200,
        off: 10,
        borderWidth: 4
      };
	  
	 var bcLink = {
        color: '#FF8ED6',
        width: 200,
        off: 10,
        borderWidth: 4
      };
	  
	  
      var cdLink = { // CD
        color: '#FF8ED6',
        width: 250,
        off: 10,
        borderWidth: 4
      };
	  
	  var adLink = { // AD
        color: 'green',
        width: 150,
        off: 10,
        borderWidth: 4
      };
      var bdLink = { // BD 
		color: 'cyan',
		width: 100,
		off: 10,
       borderWidth: 4
      };
	  
	  var bfLink = { // BF
		color: 'cyan',
		width: 100,
		off: 10,
       borderWidth: 4
      };
	  
	  
	  var efLink = { // EF
		color: 'cyan',
		width: 100,
		off: 10,
       borderWidth: 4
      };
	  
	 var beLink = { // BE
		color: 'cyan',
		width: 100,
		off: 10,
       borderWidth: 4
      };
	 
	var ceLink = { // CE
		color: 'cyan',
		width: 100,
	    off: 10,
       borderWidth: 4
      };
	  
      //draw(myLink, ctx);
      // wait one second before starting animation
//      setTimeout(function() {
    var startTime = (new Date()).getTime();
	var continueAnimating = true;
    var t = 0;
	var continueAnimating = true;
	var efLength = 100;
	var bfLength = 100;
	var slider = document.getElementById("myRange");
	var slider2 = document.getElementById("myRange2");
	var output = document.getElementById("demo");
	var output2 = document.getElementById("demo2");
	var is = false;
	output.innerHTML = slider.value;
	output2.innerHTML = slider.value;
		
	slider.oninput = function() {
		efLength = Number(this.value);
		output.innerHTML = this.value;
	}
		
	slider2.oninput = function() {
		bfLength = Number(this.value);
		output2.innerHTML = this.value;
	}
	  
    var startTime = (new Date()).getTime();
    animate(abLink, bcLink, cdLink, adLink, bdLink, efLink, beLink, ceLink, bfLink, canvas, ctx, startTime);
//      }, 1000);
    </script>
</body>
</html>

