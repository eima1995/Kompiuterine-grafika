<!DOCTYPE html>
<html lang="en">
<head>
    <title>Kompiuterinė grafika 2 užduotis</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #000;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            font-weight: bold;

            background-color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            color: #000;
            position: absolute;
            top: 10px;
            width: 100%;
            padding: 50px;

        }

        a {
            color: brown;
        }
    </style>
</head>

<body>
<div id="container"></div>
<div id="info">
</div>

<script src="three.js"></script>
<script src="TrackballControls.js"></script>
<script src="Detector.js"></script>
<script src="stats.min.js"></script>
<script src="data.js"></script>

<script>

    if (!Detector.webgl) Detector.addGetWebGLMessage();
    var container, stats;
    var camera, controls, scene, renderer;
	var faceVelocities = [];
	var pivot = new THREE.Group();
	
	var cube;

    var scale = 1;
    var wallThick = 1;
    var wallHight = 10;
	var SPEED = 0.01;

    init();
    animate();

    function init() {
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 50;
        camera.position.y = 300;
        camera.lookAt(new THREE.Vector3(0, -1, 0));

        controls = new THREE.TrackballControls(camera);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 6.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [65, 83, 68];
        controls.addEventListener('change', render);

        // world
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x9999ff);
//        scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

        var wall = {};
        var minX = 100;
        var minY = 100;
        var maxX = 1;
        var maxY = 1;
        var wallMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});
        var wallMaterial2 = new THREE.MeshLambertMaterial({color: 0x433722});
        for (var i = 0; i < data.maze.line.length; i++) {
//        for (var i = 0; i < 100; i++) {
            var x1 = data.maze.line[i]["-x1"] - 2;
            var x2 = data.maze.line[i]["-x2"] - 2;
            var y1 = data.maze.line[i]["-y1"] - 2;
            var y2 = data.maze.line[i]["-y2"] - 2;
            var x = x2 - x1;
            var y = y2 - y1;

            if (x1 < minX) {
                minX = x1;
            }
            if (x2 > maxX) {
                maxX = x2;
            }
            if (y1 < minY) {
                minY = y1;
            }
            if (y2 > maxY) {
                maxY = y2;
            }
        }
        for (var i = 0; i < data.maze.line.length; i++) {
            var x1 = data.maze.line[i]["-x1"] - 2;
            var x2 = data.maze.line[i]["-x2"] - 2;
            var y1 = data.maze.line[i]["-y1"] - 2;
            var y2 = data.maze.line[i]["-y2"] - 2;
            var x = x2 - x1;
            var y = y2 - y1;
            if (y === 0) {
                var geometry = new THREE.BoxGeometry(x, wallHight, wallThick);
                console.log('added');
                wall[i] = new THREE.Mesh(geometry, wallMaterial);
                wall[i].position.set(-maxX / 2 + x1 + x / 2, wallHight / 2, -maxY / 2 + y1 + wallThick / 2);
                scene.add(wall[i]);
            }
            if (x === 0) {
                var geometry = new THREE.BoxGeometry(wallThick, wallHight, y+wallThick);
                console.log('added');
                wall[i] = new THREE.Mesh(geometry, wallMaterial);
                wall[i].position.set(-maxX / 2 + x1 + wallThick / 2, wallHight / 2, -maxY / 2 + y1 + (y+wallThick) / 2);
                scene.add(wall[i]);
            }
			
			initCube();
            console.log(x, y);
        }
		
		function initCube() {
			//cube.position.set(150,150);
			cube = new THREE.Mesh(new THREE.CubeGeometry(4, 4, 4), new THREE.MeshNormalMaterial());
			scene.add(cube);
        }
		
		

        var floor = initFloor(maxX, maxY, 'blue');
        scene.add(floor);
//        camera.position.set(0, maxY , 0);
//        camera.lookAt(new THREE.Vector3(0, -1, 0));

        // lights
        var light = new THREE.DirectionalLight(0xff9900);
        light.position.set(150, 150, 150);
        scene.add(light);

        var light = new THREE.DirectionalLight(0xff9900);
        light.position.set(155, 155, 155);
        scene.add(light);

        var light = new THREE.AmbientLight(0x9999ff);
        scene.add(light);


        // renderer
        renderer = new THREE.WebGLRenderer({antialias: true});
		//renderer.setClearColor(0x000000);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        container = document.getElementById('container');
        container.appendChild(renderer.domElement);

        stats = new Stats();
        container.appendChild(stats.dom);

        window.addEventListener('resize', onWindowResize, false);
        render();

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        controls.handleResize();
        render();
    }

    function animate() {
	    rotateCube();
        requestAnimationFrame(animate);
        controls.update();
    }

    function render() {
        renderer.render(scene, camera);
        stats.update();
    }
	
   function rotateCube() {
		cube.rotation.x -= SPEED * 2;
		cube.rotation.y -= SPEED;
		cube.rotation.z -= SPEED * 3;
   }
	
    function initFloor(maxX, maxY, color) {
        var floor = new THREE.Mesh(
            new THREE.PlaneGeometry(maxX, maxY+wallThick*2, maxX, maxY),
            new THREE.MeshLambertMaterial({color: 'brown'})
        );

        floor.position.set(0, 0, 0);
        floor.rotation.x = -Math.PI / 2;
        return floor
    }

</script>
</body>
</html>
