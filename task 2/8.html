<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - trackball controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #000;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            font-weight: bold;

            background-color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            color: #000;
            position: absolute;
            top: 10px;
            width: 100%;
            padding: 50px;
        }

        a {
            color: red;
        }
    </style>
</head>

<body>
<div id="container"></div>
<div id="info">
</div>

<script src="three.js"></script>
<script src="TrackballControls.js"></script>
<script src="Detector.js"></script>
<script src="stats.min.js"></script>
<script src="data.js"></script>

<script>
    if (!Detector.webgl) Detector.addGetWebGLMessage();
    var container, stats;
    var camera, controls, scene, renderer;
    var wallThick = 3;
    var wallHight = 25;
    var explosiveStrength = 0;

    init();
    animate();

    function init() {
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 50;
        camera.position.y = 300;
        camera.lookAt(new THREE.Vector3(0, -1, 0));

        controls = new THREE.TrackballControls(camera);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 6.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [65, 83, 68];
        controls.addEventListener('change', render);

        // world
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xcccccc);
        scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

        var wall = {};
        var minX = 100;
        var minY = 100;
        var maxX = 1;
        var maxY = 1;
        var wallMaterial = new THREE.MeshLambertMaterial({color: 'grey'});
        var wallMaterial2 = new THREE.MeshLambertMaterial({color: 'green'});
        for (var i = 0; i < data.maze.line.length; i++) {
//        for (var i = 0; i < 100; i++) {
            var x1 = data.maze.line[i]["-x1"] - 10;
            var x2 = data.maze.line[i]["-x2"] - 10;
            var y1 = data.maze.line[i]["-y1"] - 10;
            var y2 = data.maze.line[i]["-y2"] - 10;
            if (x1 < minX) {
                minX = x1;
            }
            if (x2 > maxX) {
                maxX = x2;
            }
            if (y1 < minY) {
                minY = y1;
            }
            if (y2 > maxY) {
                maxY = y2;
            }
        }
        for (var i = 0; i < data.maze.line.length; i++) {
            var x1 = data.maze.line[i]["-x1"] - 10;
            var x2 = data.maze.line[i]["-x2"] - 10;
            var y1 = data.maze.line[i]["-y1"] - 10;
            var y2 = data.maze.line[i]["-y2"] - 10;
            var x = x2 - x1;
            var y = y2 - y1;
            if (y === 0) {
                var geometry = new THREE.BoxGeometry(x, wallHight, wallThick);
                wall[i] = new THREE.Mesh(geometry, wallMaterial);
                wall[i].position.set(-maxX / 2 + x1 + x / 2, wallHight / 2, -maxY / 2 + y1 + wallThick / 2);
                wall[i].castShadow = true;
                scene.add(wall[i]);
            }
            if (x === 0) {
                var geometry = new THREE.BoxGeometry(wallThick, wallHight, y + wallThick);
                wall[i] = new THREE.Mesh(geometry, wallMaterial);
                wall[i].position.set(-maxX / 2 + x1 + wallThick / 2, wallHight / 2, -maxY / 2 + y1 + (y + wallThick) / 2);
                wall[i].castShadow = true;
                scene.add(wall[i]);
            }
            console.log(x, y);
        }
/*
        tetGeometry = new THREE.TetrahedronGeometry(7, 2);
        var tetMaterial = new THREE.MeshLambertMaterial({color: 'pink'});
        tetMaterial.side = THREE.DoubleSide;
        tetArray = {};
        for (i = 0; i < tetGeometry.faces.length; i++) {
            geometry3 = new THREE.Geometry();
            geometry3.vertices.push(
                tetGeometry.faces[i].vertexNormals[0].add(mult(explosiveStrength, tetGeometry.faces[i].normal)),
                tetGeometry.faces[i].vertexNormals[1].add(mult(explosiveStrength, tetGeometry.faces[i].normal)),
                tetGeometry.faces[i].vertexNormals[2].add(mult(explosiveStrength, tetGeometry.faces[i].normal))
            );
            geometry3.faces.push(new THREE.Face3(0, 1, 2));
            geometry3.scale(10, 10, 10);
            tetArray[i] = new THREE.Mesh(geometry3, tetMaterial);
            scene.add(tetArray[i]);
        }
*/
//        var from = new THREE.Vector3( 0, 0, 0);
//        var to = new THREE.Vector3( 0.5, 0.5, 0.5);
//        var direction = to.clone().sub(from);
//        var length = direction.length();
//        var arrowHelper = new THREE.ArrowHelper(direction.normalize(), from, 20, 0xff0000 );
//        scene.add( arrowHelper );
//        tet.castShadow = true; //default is false

			tetGeometry = new THREE.OctahedronGeometry(1, 2);
			var tetMaterial = new THREE.MeshLambertMaterial({color: 'pink'});
			tetMaterial.side = THREE.DoubleSide;
			tetArray = {};
			//console.log(tetGeometry.faces.length);
			//scene.add(new THREE.Mesh(tetGeometry, tetMaterial));
			for (i = 0; i < tetGeometry.faces.length; i++) {
				geometry3 = new THREE.Geometry();
				geometry3.vertices.push(
				tetGeometry.faces[i].vertexNormals[0].add(mult(explosiveStrength, tetGeometry.faces[i].normal)),
				tetGeometry.faces[i].vertexNormals[1].add(mult(explosiveStrength, tetGeometry.faces[i].normal)),
				tetGeometry.faces[i].vertexNormals[2].add(mult(explosiveStrength, tetGeometry.faces[i].normal)));
				geometry3.faces.push(new THREE.Face3(0, 1, 2));
				geometry3.scale(10, 10, 10);
				tetArray[i] = new THREE.Mesh(geometry3, tetMaterial);
				scene.add(tetArray[i]);
			}
		
		/*
		cubeFaces.forEach(function (element) {
			var elementVelocity = new THREE.Vector3();
            elementVelocity.x = getAxisVelocity(element.position.x);
            elementVelocity.y = getAxisVelocity(element.position.y);
            elementVelocity.z = getAxisVelocity(element.position.z);
            faceVelocities.push(elementVelocity);
            pivot.add(element);
        }, this);
            pivot.position.x = posx;
            pivot.position.y = posy;
            pivot.position.z = posz;
            scene.add(pivot);
		*/	
        var floor = initFloor(maxX, maxY, 'brown');
        scene.add(floor[0]);
        scene.add(floor[1]);


        var ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        pointLight = new THREE.PointLight('grey', 1, 400);
        pointLight.position.set(camera.position.x, camera.position.y, camera.position.z);
        pointLight.castShadow = true;
        scene.add(pointLight);


        renderer = new THREE.WebGLRenderer({antialias: false});
//        renderer.shadowMap.enabled = true;
//        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        container = document.getElementById('container');
        container.appendChild(renderer.domElement);

        stats = new Stats();
        container.appendChild(stats.dom);

        window.addEventListener('resize', onWindowResize, false);
        render();

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        controls.handleResize();
        render();
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
        controls.update();
    }
 
    var delay = 0;
    function updateExplosive() {
        if (explosiveStrength < 1000) {
            explosiveStrength += 3 * delay;
			delay++;
			for (i = 0; i < tetGeometry.faces.length; i++) {
				tetArray[i].geometry.vertices[0] = addVectors(tetGeometry.faces[i].vertexNormals[0], mult(explosiveStrength, tetGeometry.faces[i].normal));
				tetArray[i].geometry.vertices[1] = addVectors(tetGeometry.faces[i].vertexNormals[1], mult(explosiveStrength, tetGeometry.faces[i].normal));
				tetArray[i].geometry.vertices[2] = addVectors(tetGeometry.faces[i].vertexNormals[2], mult(explosiveStrength, tetGeometry.faces[i].normal));
				tetArray[i].geometry.elementsNeedUpdate = true;
			}
			
        }
    }

	
	function checkExp(){
		if((camera.position.x < 100) && (camera.position.y < 100) && (camera.position.z < 100)){
			return true;
		}
        return false;		
	}
	/*
	function removeEntity() {
	    for(i = 0; i < tetGeometry.faces.length; i++){
			var selectedObject = scene.getObjectByName(tetArray[i]);
		    scene.remove(selectedObject );
		    animate();
        }
    }
	*/
	
    function render() {
	   console.log(camera.position);
	   if(checkExp()){
	    //console.log('salyga');
		updateExplosive();
		///removeEntity();
	   }
       pointLight.position.set(camera.position.x, camera.position.y, camera.position.z);
       renderer.render(scene, camera);
       stats.update();
    }

    function mult(a, vector) {
        return new THREE.Vector3(vector.x * a, vector.y * a, vector.z * a)
    }

    function addVectors(vector1, vector2) {
        return new THREE.Vector3(vector1.x + vector2.x, vector1.y + vector2.y, vector1.z + vector2.z)
    }

    function initFloor(maxX, maxY, color) {
        var floor = {};
        floor[0] = new THREE.Mesh(
            new THREE.PlaneGeometry(maxX, maxY + wallThick * 2, 2, 2),
            new THREE.MeshLambertMaterial({color: 'white'})
        );
        floor[0].position.set(0, 0, 0);
        floor[0].rotation.x = -Math.PI / 2;
//        floor[0].lookAt(new THREE.Vector3(-0.1,1,0));
//        floor.

        floor[0].castShadow = false;
        floor[0].receiveShadow = true;

        floor[1] = new THREE.Mesh(
            new THREE.PlaneGeometry(maxX, maxY + wallThick * 2, 2, 2),
            new THREE.MeshLambertMaterial({color: 'white'})
        );
        floor[1].position.set(0, 0, 0);
        floor[1].rotation.x = Math.PI / 2;

        return floor
    }

</script>
</body>
</html>
